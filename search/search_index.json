{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":""},{"location":"#about","title":"About","text":"<p>Welcome to the PhyloJS documentation! The PhyloJS repo can be found at https://github.com/clockor2/phylojs. </p> <p>Phylojs is a JavaScript and TypeScript library for reading, writing, and manipulating phylogenetic trees. It is intended as a utility library to manipulate trees from input and before visualisation.</p> <p>Phylojs is a small library with no dependencies. It has functions for reading trees from Newick/Extended Newick, Nexus, PhyloXML, NeXML, PhyJSON, and writing to Newick and Nexus. It includes two classes: nodes and trees, with the tree object wrapping a nesting of nodes. All the rest of the functionality is included as methods on either class, which the API describes. There are also some interactive examples of using PhyloJS.</p>"},{"location":"cite/","title":"Cite","text":""},{"location":"cite/#cite-phylojs","title":"Cite phylojs","text":"<p>If you use PhyloJS in your work, please consider citing:</p> <p>Featherstone, L. A., &amp; Wirth, W. (2024). PhyloJS: Bridging phylogenetics and web development with a JavaScript utility library. Ecology and Evolution, 14, e11603. https://doi.org/10.1002/ece3.11603</p> <pre><code>@article{featherstone_phylojs_2024,\n    title = {{PhyloJS}: {Bridging} phylogenetics and web development with a {JavaScript} utility library},\n    volume = {14},\n    url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/ece3.11603},\n    doi = {https://doi.org/10.1002/ece3.11603},\n    number = {6},\n    journal = {Ecology and Evolution},\n    author = {Featherstone, Leo A. and Wirth, Wytamma},\n    year = {2024},\n    note = {\\_eprint: https://onlinelibrary.wiley.com/doi/pdf/10.1002/ece3.11603},\n    keywords = {JavaScript, Phylogenetics, Web-Development},\n    pages = {e11603},\n}\n</code></pre>"},{"location":"node/","title":"Overview of the Node Class","text":""},{"location":"node/#node-class-in-phylojs","title":"Node Class in PhyloJS","text":"<p>The <code>Node</code> class is the foundational class used n PhyloJS. The <code>Tree</code> class wraps nested nodes. It represents a single node in a tree, with properties such as:</p> <ul> <li><code>id</code>: Numerical ID</li> <li><code>parent</code>: Parent node</li> <li><code>children</code>: Array of child nodes</li> <li><code>height</code>: Heights above the root</li> <li><code>branchLength</code>: BRanch lengths leading into the node</li> <li><code>label</code>: Name for the node</li> <li><code>annotation</code>: Any node annotations</li> <li><code>hybridID</code>: Boolean for whether node is hybrid</li> <li><code>collapsed</code>: Boolean for wehther node is collapsed</li> </ul> <p>Each node can have multiple children but only one parent. The <code>Node</code> class also includes several methods, which are documented in the API.</p>"},{"location":"reader/","title":"Reading Trees","text":""},{"location":"reader/#tree-data-import-functions-an-overview","title":"Tree Data Import Functions: An Overview","text":"<p>Here we proivde an overview of functions used for reading phylogenetic trees from different file formats. Each format\u2014NeXML, Newick, Nexus, PhyloXML, and PhyJSON\u2014has specific reading functions, which are described below.</p>"},{"location":"reader/#nexml","title":"NeXML","text":"<p><code>readNeXML(nexml: string): Tree</code> This function reads a NeXML string and returns a single tree. NeXML is an XML format designed for rich representation of phylogenetic data.</p> <p><code>readTreesFromNeXML(nexml: string): Tree[]</code> Reads NeXML strings and returns an array of trees, allowing multiple trees to be parsed from a single NeXML document.</p>"},{"location":"reader/#newick","title":"Newick","text":"<pre><code>readNewick(\n    str: string,\n    annotationParser: (annotations: string) =&gt; typeof Node.prototype.annotation = parseNewickAnnotations\n    ): Tree\n</code></pre> Parses a Newick format string and returns a tree. See API for details on the <code>annotationParser</code> function. In short, it is optional and you can ommit any reference to it if you do not need to parse annotations. That is, you can just call <code>readNewick(str)</code>. <p><code>readTreesFromNewick(newick: string): Tree[]</code> Reads multiple Newick format strings, each separated by <code>\\n</code>, and returns an array of trees.</p>"},{"location":"reader/#nexus","title":"Nexus","text":"<p><code>readNexus(nexus: string): Tree</code> Reads a single tree from Nexus format. Returns only the first tree if many are present. Nexus is a format that can include multiple types of data including trees, morphological characters, and molecular sequences.</p> <p><code>readTreesFromNexus(nexus: string): Tree[]</code> Parses Nexus format strings and returns an array of trees, supporting documents containing multiple trees.</p>"},{"location":"reader/#phyloxml","title":"PhyloXML","text":"<p><code>readPhyloXML(phyloxml: string): Tree</code> Reads a single tree from a PhyloXML format string. PhyloXML is an XML format specifically designed for phylogenetic trees and networks.</p> <p><code>readTreesFromPhyloXML(phyloxml: string): Tree[]</code> Reads multiple trees from a PhyloXML document, returning an array of trees.</p>"},{"location":"reader/#phyjson","title":"PhyJSON","text":"<p><code>readPhyJSON(phyJSONString: string): Tree</code> Parses a PhyJSON format string and returns a single tree. PhyJSON is a JSON format for phylogenetic trees.</p> <p><code>readTreesFromPhyJSON(phyJSONString: string): Tree[]</code> Reads multiple trees from a PhyJSON document, returning an array of trees.</p>"},{"location":"reader/#general-tree-reader","title":"General Tree Reader","text":"<p><code>read(text: string, schema: Schema = \u2018newick\u2019): Tree[]</code> A general function to read trees from a string according to the specified schema (<code>newick</code>, <code>nexus</code>, <code>phyloxml</code>, <code>nexml</code>, or <code>phyjson</code>). This function provides a unified interface to parse trees from different formats.</p>"},{"location":"tree/","title":"Overview of the Tree Class","text":""},{"location":"tree/#tree-class-in-typescript","title":"Tree Class in TypeScript","text":"<p>The <code>Tree</code> class is designed to handle both simple and complex tree structures, including phylogenetic networks. The class provides a variety of methods for manipulating and analyzing trees.</p>"},{"location":"tree/#properties","title":"Properties","text":"<p>The <code>Tree</code> class has several properties:</p> <ul> <li><code>root</code>: The root node of the tree.</li> <li><code>_nodeList</code>: A private property that stores a list of all nodes in the tree.</li> <li><code>nodeIDMap</code>: A map from node IDs to nodes.</li> <li><code>labelNodeMap</code>: A map from node labels to nodes.</li> <li><code>_leafList</code>: A private property that stores a list of all leaf nodes in the tree.</li> <li><code>recombEdgeMap</code>: A map from recombination edge IDs to source/destination node pairs.</li> <li><code>ultrametric</code>: A boolean indicating whether all tips are the same age.</li> </ul>"},{"location":"tree/#methods","title":"Methods","text":"<p>The <code>Tree</code> class provides a variety of methods for manipulating and analyzing trees. Below is an overview, but please see the API for a complete description:</p> <ul> <li><code>computeNodeHeights()</code>: Computes the height of each node above the root.</li> <li><code>isUltrametric()</code>: Checks whether all tips are the same age.</li> <li><code>ladderise()</code>: Orders the child nodes of each node by the number of descending tips.</li> <li><code>getBranchLengths()</code>: Returns the branch lengths in the order matching the node list.</li> <li><code>getRTTDist()</code>: Returns the root-to-tip distances.</li> <li><code>reassignNodeIDs()</code>: Assigns new node IDs.</li> <li><code>clearCaches()</code>: Clears various node caches.</li> <li><code>getNode()</code>: Gets a node given its numerical ID.</li> <li><code>getNodeByLabel()</code>: Retrieves a node given its label.</li> <li><code>getRecombEdgeMap()</code>: Retrieves a map from recombination edge IDs to source/destination node pairs.</li> <li><code>isRecombSrcNode()</code>: Checks if a node is a source node for a hybrid edge in the tree.</li> <li><code>isRecombDestNode()</code>: Checks if a node is a destination node for a hybrid edge in the tree.</li> <li><code>isNetwork()</code>: Checks if the tree is a phylogenetic network.</li> <li><code>getSubtree()</code>: Returns a subtree descending from a given node.</li> <li><code>getMRCA()</code>: Gets the most recent common ancestor of a set of nodes.</li> <li><code>getTipLabels()</code>: Gets all tip names from the tree or descending from a node.</li> <li><code>getTotalBranchLength()</code>: Returns the sum of all defined branch lengths.</li> <li><code>reroot()</code>: Reroots the tree at a given node.</li> <li><code>getInternalNodeHeights()</code>: Returns the height above the root for each internal node.</li> <li><code>gammaStatistic()</code>: Calculates the Gamma statistic from Pybus and Harvey 2000.</li> <li><code>sackinIndex()</code>: Returns the Sackin Index, which measures imbalance.</li> <li><code>isBinary()</code>: Checks whether the tree is binary.</li> <li><code>collessIndex()</code>: Returns the Colless Imbalance index.</li> </ul>"},{"location":"writer/","title":"Writing Trees","text":""},{"location":"writer/#writing-trees","title":"Writing trees","text":"<p>The <code>writeNewick</code> and <code>writeNexus</code> functions are used to convert a tree data structure back into a Newick or Nexus formatted string, respectively. Both Newick and Nexus formats are commonly used in phylogenetics to represent tree data structures.</p>"},{"location":"writer/#importing-the-functions","title":"Importing the functions","text":"<p>These functions are exported from a module. Import the functions to use them in your code as follows:</p> <pre><code>import { writeNewick, writeNexus } from 'phylojs';\n</code></pre>"},{"location":"writer/#function-signatures","title":"Function signatures","text":"<p>The <code>writeNewick</code> function has the following signature:</p> <pre><code>writeNewick(\n    tree: Tree,\n    annotationWriter: (annotation: typeof Node.prototype.annotation) =&gt; string = _annotation =&gt; ''\n): string \n</code></pre> <p>Parameters</p> <ul> <li><code>tree</code> (Tree): The tree object to be converted into a Newick string.</li> <li><code>annotationWriter</code> (annotationWriter: (annotation: typeof Node.prototype.annotation) =&gt; string = _annotation =&gt; ''): Function converting node annotations to string. Defaults to empty string(no annotation case). Can be user defined or use in-built beastAnnotation() or nhxAnnotation()</li> </ul> <p>Return</p> <ul> <li>string: A Newick formatted string representing the tree.</li> </ul> <p>The <code>writeNexus</code> function has the following signature:</p> <pre><code>writeNexus(\n    tree: Tree,\n    annotationWriter: (annotation: typeof Node.prototype.annotation) =&gt; string = _annotation =&gt; ''\n): string \n</code></pre> <p>Parameters</p> <ul> <li><code>tree</code> (Tree): The tree object to be converted into a Nexus string.</li> <li><code>annotationWriter</code> (annotationWriter: (annotation: typeof Node.prototype.annotation) =&gt; string = _annotation =&gt; ''): Function converting node annotations to string. Defaults to empty string(no annotation case). Can be user defined or use in-built beastAnnotation() or nhxAnnotation()</li> </ul> <p>Return</p> <ul> <li>string: A Nexus formatted string representing the tree.</li> </ul>"},{"location":"writer/#example-usage","title":"Example usage","text":"<pre><code>const tree; // Tree object\nconst newickString = writeNewick(tree); // annotations omitted\nconst newickString = writeNewick(tree, beastAnnotations); // include annotations as in BEAST Newick\nconst newickString = writeNewick(tree, nhxAnnotations); // include annotations as in NHX\nconst nexusString = writeNexus(tree); // Annotations options same as for `writeNewick()`\n</code></pre>"},{"location":"writer/#function-details","title":"Function details","text":"<p>The <code>writeNewick</code> function uses recursion to traverse the Tree object and build the corresponding Newick string. The <code>writeNexus</code> function, on the other hand, uses the same recursive traversal method, but appends additional Nexus-specific formatting to the output string.</p> <p>Both functions handle node labels, hybrid IDs, and annotations, as well as branch lengths.</p>"},{"location":"writer/#how-we-test-each-function","title":"How We Test Each Function","text":"<p>The module includes tests to validate both <code>writeNewick</code> and <code>writeNexus</code> functions. The tests ensure that the functions can correctly convert a Tree object back to Newick or Nexus strings, with variations for including/excluding annotations. For example:</p> <pre><code>import { writeNewick } from '../src/Write';\nimport { readNewick } from '../src/Reader';\n\ndescribe('TreeFromNewick', () =&gt; {\n  test('init', () =&gt; {\n    const inNewick = '(\"A\":1,(\"B\":1,\"C\":1):1):0.0;';\n    const tree = readNewick(inNewick);\n    const outNewick = writeNewick(tree);\n    expect(outNewick).toBe(inNewick);\n  });\n});\n</code></pre> <p>The test shown above creates a Tree object from a Newick string using the <code>readNewick</code> function. It then uses <code>writeNewick</code> to convert the tree back to a Newick string and checks if the resulting string is identical to the input string. A similar testing approach can be used for <code>writeNexus</code>.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#examples","title":"Examples","text":"<p>The following is a series of examples demonstrating how PhyloJS might be used in practice. Interactive examples are hosted with CodePen.</p>"},{"location":"examples/annotations/","title":"Modifying Annotations","text":""},{"location":"examples/annotations/#modifying-annotations","title":"Modifying annotations","text":"<p>This is another example, in addition to \"Annotations and Pre-Order Traversal\", that shows how annotations can be modified without a Pre-Order search.</p> <p>Here, we show show how annotations can be extracted and modified in a loop. We swap Blue an Green type annotations to Red and Yellow on a small tree.</p> <p>All node objects have an <code>annotation</code> field where annotations. The <code>annotation</code> field itself stores an object for all annotated tags. For example <code>Node.annotations = {Type: Blue}</code> for some leaf nodes in the following example.</p> <p>Altered annotations are then written back to newick.</p> <p> See the Pen    modify-annotations by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/annotationsPreOrder/","title":"Annotations and Pre-Order Traversal","text":""},{"location":"examples/annotationsPreOrder/#annotations-and-pre-order-traversal","title":"Annotations and Pre-Order Traversal","text":"<p>Here is an example that demonstrating how developers might work with node annotations and employ a pre-order traversal of a tree. We choose to demonstrate these together, since it makes sense to use them together. - If you want do do something to once node, it's likely you might want to apply it to other nodes given some logical condition.</p> <p>In this example, we develop a function to calculate the internal to external branch length ratio (IE ratio) of a tree - a measure of 'tippiness' with larger values corresponding to shorter external branch lengths. We then calculate the IE ratio of the subtree descending from each internal node of a starting tree, and annotate each node with this value.</p> <p>For those coming to PhyloJS without a computer sciance background (like the writer of this tutorial),  a pre-order traversal refers to the process of applying an operation to each node in a tree starting at the root and interating through each descending node. There are many other way of trversing a tree here.</p> <p>We also present this example in <code>TypeScript</code>, since it's a good example of something that might be part of a larger application where type-safety is valuable. If you want to run the example in <code>JavaScript</code>, just delete the type annotations (eg. delete <code>: number</code>, <code>: string</code>, and so on after variable declarations). You can then use the JavaScript compiler if you go to the Codepen link.</p> <p>One final thing to note is that the pre-order traversal in PhyloJS is a method on the <code>Node</code> class rather than the <code>Tree</code> class. Hence, when we do a pre-order traversal in the example code, we apply it as <code>tree.root.applyPreOrder()</code> to start at the root node. Why is it a method on Nodes rather than Trees? This is for flexibilty. - You might want to begin a pre-order traversal at an internal node, rather than for the tree as a whole.</p> <p> See the Pen    preorder-annotations by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/customAnnotationParsingAndWriting/","title":"Custom annotation parsing and writing","text":""},{"location":"examples/customAnnotationParsingAndWriting/#how-to-use-custom-annotation-parsers-and-writer-with-readnewick-and-writenewick","title":"How to use custom annotation parsers and writer with readNewick and writeNewick","text":"<p>PhyloJS provides flexibility in handling custom annotations in Newick format trees through custom parser and writer functions. This example demonstrates how to read a Newick string with custom annotations and write it back with custom formatting.</p> <p>Let's say we have a Newick tree with some custom annotation format with key value pairs separated by ';'. This is a terrible idea in practice because ';' signifies the end of a  Newick string, but for the sake of an example, let's run with it.</p> <p>NOTE: As of 17-05-2025, custom parsers still expect annotations to be enclosed in square brackets. This is a limitation of the current implementation and will be fixed in future releases.</p> <p>```javascript</p> <p> See the Pen    Custom Annotation Parsing and Writing by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/fetch/","title":"Fetching Trees from a URL","text":""},{"location":"examples/fetch/#reading-trees-from-a-url","title":"Reading trees from a URL","text":"<p>Here, we demonstrate how to read in a tree from a url using a <code>fetch()</code> request from the fetch API. In this case, we read Newick trees from a URL as part of a small app that counts the number of trees in the link and plots the first one with Phylocanvas.</p> <p>The <code>fetch()</code> request is nested in the function <code>treesFromURL()</code>, which also handles plotting data to the screen. Key features are that the fetch request is asynchronous, so we annotate it with <code>await</code> and annotate the wrapper function with <code>async</code>. You can learn more about asynchronous function in JavaScript here</p> <p>You can copy a url linking 5 trees that we use for testing here: </p><pre><code>https://raw.githubusercontent.com/clockor2/phylojs/main/test/data/egTree.nwk\n</code></pre> <p> See the Pen    fetch-url-tree by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/ladderiseApp/","title":"Ladderising App","text":""},{"location":"examples/ladderiseApp/#ladderising-newick-trees","title":"Ladderising Newick Trees","text":"<p>Here is an example of an app that ladderises a user supplied Newick string. It also plots the tree with phylocanvas to show users the ladderisation.</p> <p>You can paste in any Newick string, or use the following for convenience:</p> <pre><code>(t4:1,(((t2:1,t7:1):1,(t1:1,t3:1):1):1,(t6:1,t5:1):1):1);\n</code></pre> <p> See the Pen    ladderise-app by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/mrca/","title":"Extracting Clades","text":""},{"location":"examples/mrca/#extracting-clades","title":"Extracting Clades","text":"<p>This script demonstrates how the <code>getNodeByLabel</code>, <code>getMRCA</code>, and <code>getClade</code> methods on the <code>Tree</code> class can be wrapped in a function to find and extract clades relating a subset of tips. </p> <p>The particular function here takes a Newick string and list of desired taxa. We use TypeScript here as this would likely be part of a larger application needing type safety. Just remove type annotations and change the compiler in codepen to run it in JavaScript.</p> <p> See the Pen    extract-subtree by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/pruneGraft/","title":"Pruning and Grafting","text":"<p>Here we demonstrate pruning and grafting of nodes usig the <code>.addChild()</code> and <code>.removeChild()</code> methods on the <code>Node</code> class. In effect, these can be used to add or remove clades and tips.</p> <p>As a general note, using the <code>.copy()</code> method produces a deep copy of a node, and so is useful to avoid recursion issues, especially with iterative grafting.</p> <p> See the Pen    prune-graft by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/rerootingApp/","title":"Random-Rerooting App","text":""},{"location":"examples/rerootingApp/#visualisation","title":"Visualisation","text":"<p>Here is a minimal example of a small app that randomly reroots a starting tree. We parse a tree and use phylojs to reroot it randomly in a html widget. We use phylocanvas to visualise the tree. This example demonstrates rerooting, and connection with a plotting library such as phylocanvas.</p> <p> See the Pen    visualise-reroot by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/rerootingApp/#how-random-rerooting-works","title":"How random rerooting works","text":"<pre><code>// Randomly reroot tree on button click\nfunction onClick() {\n\n    // Returns an index from 1,...,nNodes (0 is the root)\n    let randomIndex = Math.floor(nNodes * Math.random() + 1)\n\n    // Select node corresponding to index\n    let randomNode = tree.nodeList[randomIndex]\n\n    tree.reroot(randomNode)\n\n    treeVis.setProps({\n        source: phylojs.writeNewick(tree)\n    })\n\n}\n</code></pre>"},{"location":"examples/rttr/","title":"Root-to-tip regression","text":""},{"location":"examples/rttr/#root-to-tip-regression","title":"Root-to-tip Regression","text":"<p>In this example we will do a root to tip regression on a small, fixed tree.</p> <p>This examples uses code directly from Clockor2, which was the origial impetus for developing PhyloJS into a complete library.</p> <p>We will demonstrate use of <code>Tree.getRTTDist()</code>, <code>Tree.getTipLabels()</code>, and the <code>readNewick()</code> function. </p> <p> See the Pen    root-to-tip-regression by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/toNewickApp/","title":"Newick Conversion App","text":""},{"location":"examples/toNewickApp/#convert-to-extended-newick","title":"Convert to Extended Newick","text":"<p>Here we build an app that takes any of PhyloJS' supported tree-file formats, and outputs then to Extended Newick. If the tree doesn't contain reticulations (hybrid nodes), then the output will just be standard newick.</p> <p>This app demonstrates how one can read a tree using PhyloJS from a user input file with the <code>read()</code> function. This would be useful, for apps expecting multiple different file types.</p> <p>If you don't have a tree in any of the above formats handy to test out, then you can download a small Nexus tree here.</p> <p> See the Pen    to-newick by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/treeArray/","title":"Arrays of Trees","text":""},{"location":"examples/treeArray/#working-with-arrays-of-trees","title":"Working with arrays of trees","text":"<p>This example demonstrates how one can manipulate an array of trees for efficient bulk processing.</p> <p>Arrays of trees (<code>Tree[]</code>) can be read in with any of the <code>readTrees*()</code> functions. That is, <code>readTreesFromNewick()</code>, <code>readTreesFromNexus()</code>, <code>readTreesFromPhyloXML()</code>, and <code>readTreesFromNeXML()</code>. The <code>read()</code> function also returns an array of trees, taking flags for the input string and expected file format.</p> <p>In the below example, we parse two trees from phyloXML format, reroot them, rescale their branches randomly, and ladderise. Output is then written to newick where it could, for example, be passed to visualisation code.</p> <p> See the Pen    tree-arrays by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"},{"location":"examples/treeStatsApp/","title":"Tree Statistics App","text":""},{"location":"examples/treeStatsApp/#app-for-basic-tree-statistics","title":"App for basic tree statistics","text":"<p>Here we build an app that calculates basic tree statistics for a given input tree.</p> <p>Note that because we calculate the Gamma Statistic (Pybus and Harvey 2000), we need an ultrametric tree as input, meaning a tree where all the leaves are the same distance above the root.</p> <p>In PhyloJS, you can check this using the <code>isUltrametric()</code> method on the <code>Tree</code> class, but for the sake of simplicity we leave it to the user to ensure the tree is ultrametric. As an aside, PhyloJS allows for a difference of 1e-6 between tip heights above the root when deciding if a tree is ultrametric. Users can set this tolerance though (see API).</p> <p>If you don't have an ultremetric tree in any of the above formats handy to test out, then you can download a small Newick tree here.</p> <p> See the Pen    tree-stats by Leo Featherstone (@LeoFeatherstone)   on CodePen. </p>"}]}